-- Generated by Haxe 3.4.0 (git build development @ bd68468)
local function _hx_anon_newindex(t,k,v) t.__fields__[k] = true; rawset(t,k,v); end
local _hx_anon_mt = {__newindex=_hx_anon_newindex}
local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_anon_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_anon_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_anon_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_anon_newindex, __index=prototype})
end

local _hxClasses = {}
Int = (function() _hxClasses.Int = _hx_o({__fields__={__name__=true},__name__={"Int"}}); return _hxClasses.Int end)();
Dynamic = (function() 
_hxClasses.Dynamic = _hx_o({__fields__={__name__=true},__name__={"Dynamic"}}); return _hxClasses.Dynamic end)();
Float = (function() 
_hxClasses.Float = _hx_e(); return _hxClasses.Float end)();
Float.__name__ = {"Float"}
Bool = (function() 
_hxClasses.Bool = _hx_e(); return _hxClasses.Bool end)();
Bool.__ename__ = {"Bool"}
Class = (function() 
_hxClasses.Class = _hx_o({__fields__={__name__=true},__name__={"Class"}}); return _hxClasses.Class end)();
Enum = _hx_e();

local _hx_array_mt = {
  __newindex = function(t,k,v)
    local len = t.length
    t.length =  k >= len and (k + 1) or len
    rawset(t,k,v)
  end
}

local function _hx_tab_array(tab,length)
  tab.length = length
  return setmetatable(tab, _hx_array_mt)
end

local _hx_exports = _hx_exports or {}
_hx_exports["gui"] = _hx_exports["gui"] or _hx_e()
local Array = _hx_e()
local defold = {}
defold.support = {}
defold.support.Script = _hx_e()
local Block = _hx_e()
local Board = _hx_e()
local Connector = _hx_e()
local MagicFx = _hx_e()
local Main = _hx_e()
local Math = _hx_e()
local Messages = _hx_e()
local String = _hx_e()
local Std = _hx_e()
defold.CollectionproxyMessages = _hx_e()
defold.GoMessages = _hx_e()
defold.GoProperties = _hx_e()
defold.GuiMessages = _hx_e()
defold.SpriteMessages = _hx_e()
defold.support.GuiScript = _hx_e()
defold.types = {}
defold.types._Message = {}
defold.types._Message.Message_Impl_ = _hx_e()
defold.types._Property = {}
defold.types._Property.Property_Impl_ = _hx_e()
defold.types._Property.Vector3Property_Impl_ = _hx_e()
defold.types._Property.Vector4Property_Impl_ = _hx_e()
defold.types._Property.QuaternionProperty_Impl_ = _hx_e()
local gui = {}
gui.Board = _hx_e()
gui.LevelComplete = _hx_e()
gui.MainMenu = _hx_e()
gui.NoDropRoom = _hx_e()
gui.PresentLevel = _hx_e()
gui.Restart = _hx_e()
local haxe = {}
haxe.Log = _hx_e()
haxe.io = {}
haxe.io.Eof = _hx_e()
local lua = {}
lua.Boot = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw

Array.new = {}
Array.prototype = _hx_a(
  'join', function(self,sep) 
    local tbl = ({});
    local _gthis = self;
    local cur_length = 0;
    local i = _hx_o({__fields__={hasNext=true,next=true},hasNext=function() 
      do return cur_length < _gthis.length end;
    end,next=function() 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end});
    while (i:hasNext()) do 
      _G.table.insert(tbl,Std.string(i:next()));
      end;
    do return _G.table.concat(tbl,sep) end
  end,
  'push', function(self,x) 
    _G.rawset(self,self.length,x);
    _G.rawset(self,"length",self.length + 1);
    do return _G.rawget(self,"length") end
  end,
  'splice', function(self,pos,len) 
    if ((len < 0) or (pos > self.length)) then 
      do return _hx_tab_array({ }, 0) end;
    else
      if (pos < 0) then 
        pos = self.length - (_G.math.fmod(-pos, self.length));
      end;
    end;
    local b = self.length - pos;
    len = (function() 
      local _hx_1
      if (Math.isNaN(len) or Math.isNaN(b)) then 
      _hx_1 = (0/0); else 
      _hx_1 = _G.math.min(len,b); end
      return _hx_1
    end )();
    local ret = _hx_tab_array({ }, 0);
    local _g1 = pos;
    local _g = pos + len;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      ret:push(self[i]);
      self[i] = self[i + len];
      end;
    local _g11 = pos + len;
    local _g2 = self.length;
    while (_g11 < _g2) do 
      _g11 = _g11 + 1;
      local i1 = _g11 - 1;
      self[i1] = self[i1 + len];
      end;
    local tmp = self;
    tmp.length = tmp.length - len;
    do return ret end
  end,
  'filter', function(self,f) 
    local _g = _hx_tab_array({ }, 0);
    local _g1 = 0;
    local _g2 = self;
    while (_g1 < _g2.length) do 
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      if (f(i)) then 
        _g:push(i);
      end;
      end;
    do return _g end
  end,
  'iterator', function(self) 
    local _gthis = self;
    local cur_length = 0;
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function() 
      do return cur_length < _gthis.length end;
    end,next=function() 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end}) end
  end
)

defold.support.Script.new = function() 
  local self = _hx_new(defold.support.Script.prototype)
  defold.support.Script.super(self)
  return self
end
defold.support.Script.super = function(self) 
end
defold.support.Script.prototype = _hx_a(
  'init', function(self,_self) 
  end,
  'final', function(self,_self) 
  end,
  'update', function(self,_self,dt) 
  end,
  'on_message', function(self,_self,message_id,message,sender) 
  end,
  'on_input', function(self,_self,action_id,action) 
    do return false end
  end,
  'on_reload', function(self,_self) 
  end
)

Block.new = function() 
  local self = _hx_new(Block.prototype)
  Block.super(self)
  return self
end
Block.super = function(self) 
  defold.support.Script.super(self);
end
_hx_exports["Block"] = Block
Block.prototype = _hx_a(
  'init', function(self,_self) 
    _G.go.set_scale(0.18);
    _self.fx1 = nil;
    _self.fx2 = nil;
    _G.msg.post("#cover",defold.GoMessages.disable);
    if (_self.color ~= nil) then 
      _G.msg.post("#sprite",defold.SpriteMessages.play_animation,_hx_o({__fields__={id=true},id=_self.color}));
    else
      _G.msg.post("#sprite",defold.GoMessages.disable);
    end;
  end,
  'final', function(self,_self) 
    if (_self.fx1 ~= nil) then 
      _G.go.delete(_self.fx1);
    end;
    if (_self.fx2 ~= nil) then 
      _G.go.delete(_self.fx2);
    end;
    if (_self.cover ~= nil) then 
      _G.go.delete(_self.cover);
    end;
  end,
  'on_message', function(self,_self,message_id,message,_) 
    local message_id1 = message_id;
    if (message_id1) == Messages.lights_off or (message_id1) == Messages.lights_on then 
      _G.msg.post(_self.fx1,message_id);
      _G.msg.post(_self.fx2,message_id);
    elseif (message_id1) == Messages.make_magic then 
      _self.color = _G.hash("magic");
      _G.msg.post("#cover",defold.GoMessages.enable);
      _G.msg.post("#sprite",defold.GoMessages.enable);
      _G.msg.post("#sprite",defold.SpriteMessages.play_animation,_hx_o({__fields__={id=true},id=_G.hash("magic-sphere_layer1")}));
      local hleft = _G.hash("left");
      local hright = _G.hash("right");
      _self.fx1 = _G.factory.create("#fxfactory",_G.vmath.vector3(0,0,0),nil,({direction = hleft}));
      _self.fx2 = _G.factory.create("#fxfactory",_G.vmath.vector3(0,0,0),nil,({direction = hright}));
      _G.msg.post(_self.fx1,defold.GoMessages.set_parent,_hx_o({__fields__={parent_id=true,keep_world_transform=true},parent_id=_G.go.get_id(),keep_world_transform=0}));
      _G.msg.post(_self.fx2,defold.GoMessages.set_parent,_hx_o({__fields__={parent_id=true,keep_world_transform=true},parent_id=_G.go.get_id(),keep_world_transform=0}));
      _G.go.set(_self.fx1,_G.hash(Std.string(defold.GoProperties.position) .. ".z"),0.01);
      _G.go.set(_self.fx1,defold.GoProperties.scale_uniform,1);
      _G.go.set(_self.fx2,_G.hash(Std.string(defold.GoProperties.position) .. ".z"),0.02);
      _G.go.set(_self.fx2,defold.GoProperties.scale_uniform,1); end;
  end
)
Block.__super__ = defold.support.Script
setmetatable(Block.prototype,{__index=defold.support.Script.prototype})

Board.new = function() 
  local self = _hx_new(Board.prototype)
  Board.super(self)
  return self
end
Board.super = function(self) 
  defold.support.Script.super(self);
end
_hx_exports["Board"] = Board
Board.build_blocklist = function(_self) 
  _self.blocks = _hx_tab_array({ }, 0);
  local _g1 = 0;
  local _g = _self.board.length;
  while (_g1 < _g) do 
    _g1 = _g1 + 1;
    local col = _self.board[_g1 - 1];
    local _g3 = 0;
    local _g2 = col.length;
    while (_g3 < _g2) do 
      _g3 = _g3 + 1;
      local b = col[_g3 - 1];
      _self.blocks:push(_hx_o({__fields__={id=true,color=true,x=true,y=true},id=b.id,color=b.color,x=b.x,y=b.y}));
      end;
    end;
end
Board.magic_blocks = function(_self) 
  local magic = _hx_tab_array({ }, 0);
  local _g = 0;
  while (_g < 7) do 
    _g = _g + 1;
    local x = _g - 1;
    local _g1 = 0;
    while (_g1 < 9) do 
      _g1 = _g1 + 1;
      local block = _self.board[x][_g1 - 1];
      if ((block ~= nil) and (block.color == _G.hash("magic"))) then 
        magic:push(block);
      end;
      end;
    end;
  do return magic end;
end
Board.count_magic_regions = function(blocks) 
  local maxr = 0;
  local _g = 0;
  while (_g < blocks.length) do 
    local m = blocks[_g];
    _g = _g + 1;
    if (m.region > maxr) then 
      maxr = m.region;
    end;
    end;
  do return maxr end;
end
Board.adjacent_magic_blocks = function(blocks,block) 
  do return blocks:filter(function(e) 
    if (not ((block.x == e.x) and (_G.math.abs(block.y - e.y) == 1))) then 
      if (block.y == e.y) then 
        do return _G.math.abs(block.x - e.x) == 1 end;
      else
        do return false end;
      end;
    else
      do return true end;
    end;
  end) end;
end
Board.mark_neighbors = function(blocks,block,region) 
  local neighbors = Board.adjacent_magic_blocks(blocks,block);
  local _g = 0;
  while (_g < neighbors.length) do 
    local m = neighbors[_g];
    _g = _g + 1;
    if (m.region == nil) then 
      m.region = region;
      Board.mark_neighbors(blocks,m,region);
    end;
    end;
end
Board.mark_magic_regions = function(_self) 
  local m_blocks = Board.magic_blocks(_self);
  local _g = 0;
  while (_g < m_blocks.length) do 
    local m = m_blocks[_g];
    _g = _g + 1;
    m.region = nil;
    m.neighbors = Board.adjacent_magic_blocks(m_blocks,m).length;
    end;
  local region = 1;
  local _g1 = 0;
  while (_g1 < m_blocks.length) do 
    local m1 = m_blocks[_g1];
    _g1 = _g1 + 1;
    if (m1.region == nil) then 
      m1.region = region;
      Board.mark_neighbors(m_blocks,m1,region);
      region = region + 1;
    end;
    end;
  do return m_blocks end;
end
Board.highlight_magic = function(blocks) 
  local _g = 0;
  while (_g < blocks.length) do 
    local m = blocks[_g];
    _g = _g + 1;
    if (m.neighbors > 0) then 
      _G.msg.post(m.id,Messages.lights_on);
    else
      _G.msg.post(m.id,Messages.lights_off);
    end;
    end;
end
Board.clear_board = function(_self) 
  local _g = 0;
  local _g1 = _self.board;
  while (_g < _g1.length) do 
    local col = _g1[_g];
    _g = _g + 1;
    local _g3 = 0;
    local _g2 = col.length;
    while (_g3 < _g2) do 
      _g3 = _g3 + 1;
      local i = _g3 - 1;
      if (col[i] ~= nil) then 
        _G.go.delete(col[i].id);
        col[i] = nil;
      end;
      end;
    end;
end
Board.same_color_neighbors = function(_self,x,y) 
  do return _self.blocks:filter(function(v) 
    if (((v.id ~= _self.board[x][y].id) and (((v.x == x) or (v.x == (x - 1))) or (v.x == (x + 1)))) and (((v.y == y) or (v.y == (y - 1))) or (v.y == (y + 1)))) then 
      do return v.color == _self.board[x][y].color end;
    else
      do return false end;
    end;
  end) end;
end
Board.remove_chain = function(_self) 
  local _g = 0;
  local _g1 = _self.chain;
  while (_g < _g1.length) do 
    local c = _g1[_g];
    _g = _g + 1;
    _self.board[c.x][c.y] = Board.REMOVING_BLOCK;
    _G.go.delete(c.id);
    end;
  _self.chain = _hx_tab_array({ }, 0);
end
Board.nilremoved = function(_self) 
  local _g = 0;
  local _g1 = _self.board;
  while (_g < _g1.length) do 
    local col = _g1[_g];
    _g = _g + 1;
    local _g3 = 0;
    local _g2 = col.length;
    while (_g3 < _g2) do 
      _g3 = _g3 + 1;
      local i = _g3 - 1;
      if (col[i] == Board.REMOVING_BLOCK) then 
        col[i] = nil;
      end;
      end;
    end;
end
Board.in_blocklist = function(blocks,block) 
  local _g = 0;
  while (_g < blocks.length) do 
    local b = blocks[_g];
    _g = _g + 1;
    if (b.id == block) then 
      do return true end;
    end;
    end;
  do return false end;
end
Board.dropspots = function(_self) 
  local spots = _hx_tab_array({ }, 0);
  local _g = 0;
  while (_g < 7) do 
    _g = _g + 1;
    local x = _g - 1;
    local _g1 = 0;
    while (_g1 < 9) do 
      _g1 = _g1 + 1;
      local y = _g1 - 1;
      if (_self.board[x][y] == nil) then 
        spots:push(_hx_o({__fields__={x=true,y=true},x=x,y=y}));
        break;
      end;
      end;
    end;
  local _g11 = 1;
  local _g2 = spots.length - 3;
  while (_g11 < _g2) do 
    _g11 = _g11 + 1;
    spots:splice(Std.random(spots.length),1);
    end;
  do return spots end;
end
Board.drop = function(_self,spots) 
  local _g = 0;
  while (_g < spots.length) do 
    local s = spots[_g];
    _g = _g + 1;
    local pos = _G.vmath.vector3();
    pos.x = 80. + (80 * s.x);
    pos.y = 1000;
    local c = Board.colors[Std.random(Board.colors.length)];
    local id = _G.factory.create("#blockfactory",pos,nil,({color = c}));
    _G.go.animate(id,_G.hash(Std.string(defold.GoProperties.position) .. ".y"),_G.go.PLAYBACK_ONCE_FORWARD,90. + (80 * s.y),_G.go.EASING_OUTBOUNCE,0.5);
    _G.go.set(id,_G.hash(Std.string(defold.GoProperties.position) .. ".z"),(s.x * -0.1) + (s.y * 0.01));
    _self.board[s.x][s.y] = _hx_o({__fields__={id=true,color=true,x=true,y=true},id=id,color=c,x=s.x,y=s.y});
    end;
  Board.build_blocklist(_self);
end
Board.slide_board = function(_self) 
  local _g = 0;
  while (_g < 7) do 
    _g = _g + 1;
    local x = _g - 1;
    local dy = 0;
    local _g1 = 0;
    while (_g1 < 9) do 
      _g1 = _g1 + 1;
      local y = _g1 - 1;
      if (_self.board[x][y] ~= nil) then 
        if (dy > 0) then 
          _self.board[x][y - dy] = _self.board[x][y];
          _self.board[x][y] = nil;
          _self.board[x][y - dy].y = _self.board[x][y - dy].y - dy;
          _G.go.animate(_self.board[x][y - dy].id,_G.hash(Std.string(defold.GoProperties.position) .. ".y"),_G.go.PLAYBACK_ONCE_FORWARD,90. + (80 * (y - dy)),_G.go.EASING_OUTBOUNCE,0.3);
          _G.go.set(_self.board[x][y - dy].id,_G.hash(Std.string(defold.GoProperties.position) .. ".z"),(x * -0.1) + ((y - dy) * 0.01));
        end;
      else
        dy = dy + 1;
      end;
      end;
    end;
  Board.build_blocklist(_self);
end
Board.build_board = function(_self) 
  _G.math.randomseed(_G.os.time());
  local pos = _G.vmath.vector3();
  local _g = 0;
  while (_g < 7) do 
    _g = _g + 1;
    local x = _g - 1;
    pos.x = 80. + (80 * x);
    _self.board[x] = _hx_tab_array({ }, 0);
    local _g1 = 0;
    while (_g1 < 9) do 
      _g1 = _g1 + 1;
      local y = _g1 - 1;
      pos.y = 90. + (80 * y);
      pos.z = (x * -0.1) + (y * 0.01);
      local c = Board.colors[Std.random(Board.colors.length)];
      local id = _G.factory.create("#blockfactory",pos,nil,({color = c}));
      _self.board[x][y] = _hx_o({__fields__={id=true,color=true,x=true,y=true},id=id,color=c,x=x,y=y});
      end;
    end;
  local y1 = 0;
  local step = Std.int(9 / _self.num_magic);
  while (y1 < 9) do 
    local set = false;
    while (not set) do 
      local rand_y = _G.math.floor(y1);
      local b = _G.math.floor(y1 + (9 / _self.num_magic));
      local rand_y1 = Std.int(_G.math.random(rand_y,(function() 
        local _hx_1
        if (Math.isNaN(8) or Math.isNaN(b)) then 
        _hx_1 = (0/0); else 
        _hx_1 = _G.math.min(8,b); end
        return _hx_1
      end )()));
      local rand_x = Std.int(_G.math.random(0,6));
      if (_self.board[rand_x][rand_y1].color ~= _G.hash("magic")) then 
        _G.msg.post(_self.board[rand_x][rand_y1].id,Messages.make_magic);
        _self.board[rand_x][rand_y1].color = _G.hash("magic");
        set = true;
      end;
      end;
    y1 = y1 + step;
    end;
  Board.build_blocklist(_self);
  local magic_blocks = Board.mark_magic_regions(_self);
  if (Board.count_magic_regions(magic_blocks) == 1) then 
    Board.clear_board(_self);
    Board.build_board(_self);
  end;
  Board.highlight_magic(magic_blocks);
end
Board.slide_magic_blocks = function(_self) 
  local _g = 0;
  while (_g < 9) do 
    _g = _g + 1;
    local y = _g - 1;
    local row_m = _hx_tab_array({ }, 0);
    local _g1 = 0;
    while (_g1 < 7) do 
      _g1 = _g1 + 1;
      local x = _g1 - 1;
      if (((_self.board[x][y] ~= nil) and (_self.board[x][y] ~= Board.REMOVING_BLOCK)) and (_self.board[x][y].color == _G.hash("magic"))) then 
        row_m:push(_self.board[x][y]);
      end;
      end;
    local mc = row_m.length + 1;
    while (row_m.length < mc) do 
      mc = row_m.length;
      local _g2 = 0;
      local _g11 = row_m.length;
      while (_g2 < _g11) do 
        _g2 = _g2 + 1;
        local i = _g2 - 1;
        local x1 = row_m[i].x;
        haxe.Log.trace(i,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true,customParams=true},fileName="Board.hx",lineNumber=401,className="Board",methodName="slide_magic_blocks",customParams=_hx_tab_array({[0]=x1, y }, 2)}));
        if ((y > 0) and (_self.board[x1][y - 1] == Board.REMOVING_BLOCK)) then 
          haxe.Log.trace(i,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Board.hx",lineNumber=404,className="Board",methodName="slide_magic_blocks"}));
          row_m[i] = nil;
        else
          if ((x1 > 0) and (_self.board[x1 - 1][y] == Board.REMOVING_BLOCK)) then 
            _self.board[x1 - 1][y] = _self.board[x1][y];
            _self.board[x1 - 1][y].x = x1 - 1;
            _G.go.animate(_self.board[x1][y].id,_G.hash(Std.string(defold.GoProperties.position) .. ".x"),_G.go.PLAYBACK_ONCE_FORWARD,80. + (80 * (x1 - 1)),_G.go.EASING_OUTBOUNCE,0.3);
            _G.go.set(_self.board[x1][y].id,_G.hash(Std.string(defold.GoProperties.position) .. ".z"),((x1 - 1) * -0.1) + (y * 0.01));
            _self.board[x1][y] = Board.REMOVING_BLOCK;
            haxe.Log.trace(i,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Board.hx",lineNumber=414,className="Board",methodName="slide_magic_blocks"}));
            row_m[i] = nil;
          else
            if ((x1 < 6) and (_self.board[x1 + 1][y] == Board.REMOVING_BLOCK)) then 
              _self.board[x1 + 1][y] = _self.board[x1][y];
              _self.board[x1 + 1][y].x = x1 + 1;
              _G.go.animate(_self.board[x1 + 1][y].id,_G.hash(Std.string(defold.GoProperties.position) .. ".x"),_G.go.PLAYBACK_ONCE_FORWARD,80. + (80 * (x1 + 1)),_G.go.EASING_OUTBOUNCE,0.3);
              _G.go.set(_self.board[x1 + 1][y].id,_G.hash(Std.string(defold.GoProperties.position) .. ".z"),((x1 + 1) * -0.1) + (y * 0.01));
              _self.board[x1][y] = Board.REMOVING_BLOCK;
              row_m[i] = nil;
            end;
          end;
        end;
        end;
      end;
    end;
end
Board.prototype = _hx_a(
  'init', function(self,_self) 
    _self.board = _hx_tab_array({ }, 0);
    _self.blocks = _hx_tab_array({ }, 0);
    _self.chain = _hx_tab_array({ }, 0);
    _self.connectors = _hx_tab_array({ }, 0);
    _self.num_magic = 3;
    _self.drops = 1;
    _self.dragging = false;
  end,
  'on_message', function(self,_self,message_id,message,_) 
    if (message_id) == Messages.drop then 
      local s = Board.dropspots(_self);
      if (s.length == 0) then 
        _G.msg.post("no_drop_room#gui",Messages.show);
      else
        if (_self.drops > 0) then 
          Board.drop(_self,s);
          _self.drops = _self.drops - 1;
          _G.msg.post("#gui",Messages.set_drop_counter,_hx_o({__fields__={drops=true},drops=_self.drops}));
        end;
      end;
    elseif (message_id) == Messages.level_completed then 
      _G.msg.post(".",defold.GoMessages.release_input_focus);
      local _g = 0;
      local _g1 = Board.magic_blocks(_self);
      while (_g < _g1.length) do 
        local m = _g1[_g];
        _g = _g + 1;
        _G.go.set_scale(0.17,m.id);
        _G.go.animate(m.id,defold.GoProperties.scale_uniform,_G.go.PLAYBACK_LOOP_PINGPONG,0.19,_G.go.EASING_INSINE,0.5,0);
        end;
      _G.msg.post("level_complete#gui",Messages.show);
    elseif (message_id) == Messages.next_level then 
      Board.clear_board(_self);
      _self.drops = _self.drops + 1;
      _G.msg.post("#",Messages.start_level,_hx_o({__fields__={difficulty=true},difficulty=_self.num_magic}));
    elseif (message_id) == Messages.restart_level then 
      Board.clear_board(_self);
      Board.build_board(_self);
      _self.drops = 1;
      _G.msg.post("#gui",Messages.set_drop_counter,_hx_o({__fields__={drops=true},drops=_self.drops}));
      _G.msg.post(".",defold.GoMessages.acquire_input_focus);
    elseif (message_id) == Messages.start_level then 
      _self.num_magic = message.difficulty + 1;
      Board.build_board(_self);
      _G.msg.post("#gui",Messages.set_drop_counter,_hx_o({__fields__={drops=true},drops=_self.drops}));
      _G.msg.post("present_level#gui",gui.PresentLevel.ShowMessage,_hx_o({__fields__={level=true},level=message.difficulty}));
      _G.go.animate("#",_G.hash("timer"),_G.go.PLAYBACK_ONCE_FORWARD,1,_G.go.EASING_LINEAR,2,0,function(_1,_2,_3) 
        _G.msg.post("present_level#gui",Messages.hide);
        _G.msg.post(".",defold.GoMessages.acquire_input_focus);
      end); end;
  end,
  'on_input', function(self,_self,action_id,action) 
    if (action_id ~= _G.hash("touch")) then 
      do return false end;
    end;
    if (action.value == 1) then 
      local x = _G.math.floor((action.x - 40) / 80);
      local y = _G.math.floor((action.y - 40) / 80);
      if (((((x < 0) or (x >= 7)) or (y < 0)) or (y >= 9)) or (_self.board[x][y] == nil)) then 
        do return false end;
      end;
      if (_self.board[x][y].color == _G.hash("magic")) then 
        do return false end;
      end;
      if (action.pressed) then 
        _self.neighbors = Board.same_color_neighbors(_self,x,y);
        _self.chain = _hx_tab_array({[0]=_self.board[x][y] }, 1);
        local p = _G.go.get_position(_self.board[x][y].id);
        local b = Board.centeroff;
        _self.connectors:push(_G.factory.create("#connectorfactory",(p) + (b)));
        _self.dragging = true;
      else
        if (_self.dragging) then 
          if (Board.in_blocklist(_self.neighbors,_self.board[x][y].id) and not Board.in_blocklist(_self.chain,_self.board[x][y].id)) then 
            _self.chain:push(_self.board[x][y]);
            _self.neighbors = Board.same_color_neighbors(_self,x,y);
            local p1 = _G.go.get_position(_self.board[x][y].id);
            local b1 = Board.centeroff;
            local id = _G.factory.create("#connectorfactory",(p1) + (b1));
            _self.connectors:push(id);
          end;
        end;
      end;
    else
      if (action.released) then 
        _self.dragging = false;
        if (_self.chain.length > 1) then 
          Board.remove_chain(_self);
          Board.slide_magic_blocks(_self);
          Board.nilremoved(_self);
          Board.slide_board(_self);
          local magic_blocks = Board.mark_magic_regions(_self);
          if (Board.count_magic_regions(magic_blocks) == 1) then 
            _G.msg.post("#",Messages.level_completed);
          end;
          Board.highlight_magic(magic_blocks);
        end;
        local _g = 0;
        local _g1 = _self.connectors;
        while (_g < _g1.length) do 
          local c = _g1[_g];
          _g = _g + 1;
          _G.go.delete(c);
          end;
        _self.connectors = _hx_tab_array({ }, 0);
      end;
    end;
    do return false end
  end,
  'on_reload', function(self,_) 
  end
)
Board.__super__ = defold.support.Script
setmetatable(Board.prototype,{__index=defold.support.Script.prototype})

Connector.new = function() 
  local self = _hx_new(Connector.prototype)
  Connector.super(self)
  return self
end
Connector.super = function(self) 
  defold.support.Script.super(self);
end
_hx_exports["Connector"] = Connector
Connector.prototype = _hx_a(
  'init', function(self,_) 
    _G.go.set_scale(0.18);
    _G.go.set(".",_G.hash(Std.string(defold.GoProperties.position) .. ".z"),1);
  end
)
Connector.__super__ = defold.support.Script
setmetatable(Connector.prototype,{__index=defold.support.Script.prototype})

MagicFx.new = function() 
  local self = _hx_new(MagicFx.prototype)
  MagicFx.super(self)
  return self
end
MagicFx.super = function(self) 
  defold.support.Script.super(self);
end
_hx_exports["MagicFx"] = MagicFx
MagicFx.prototype = _hx_a(
  'init', function(self,_self) 
    _G.msg.post("#",Messages.lights_off);
    if (_self.direction == _G.hash("left")) then 
      _G.go.set(".",_G.hash(Std.string(defold.GoProperties.euler) .. ".z"),0);
      _G.go.animate(".",_G.hash(Std.string(defold.GoProperties.euler) .. ".z"),_G.go.PLAYBACK_LOOP_FORWARD,360,_G.go.EASING_LINEAR,5 + _G.math.random());
    else
      _G.go.set(".",_G.hash(Std.string(defold.GoProperties.euler) .. ".z"),0);
      _G.go.animate(".",_G.hash(Std.string(defold.GoProperties.euler) .. ".z"),_G.go.PLAYBACK_LOOP_FORWARD,-360,_G.go.EASING_LINEAR,4 + _G.math.random());
    end;
  end,
  'on_message', function(self,_self,message_id,message,_) 
    if (message_id) == Messages.lights_off then 
      _G.msg.post("#light",defold.GoMessages.disable);
    elseif (message_id) == Messages.lights_on then 
      _G.msg.post("#light",defold.GoMessages.enable); end;
  end
)
MagicFx.__super__ = defold.support.Script
setmetatable(MagicFx.prototype,{__index=defold.support.Script.prototype})

Main.new = function() 
  local self = _hx_new(Main.prototype)
  Main.super(self)
  return self
end
Main.super = function(self) 
  defold.support.Script.super(self);
end
_hx_exports["Main"] = Main
Main.prototype = _hx_a(
  'init', function(self,_self) 
    _G.msg.post("#",Messages.to_main_menu);
    _self.state = "MAIN_MENU";
    _G.particlefx.play("#particlefx");
  end,
  'on_message', function(self,_self,message_id,message,sender) 
    if (message_id) == defold.CollectionproxyMessages.proxy_loaded then 
      _G.msg.post(sender,defold.CollectionproxyMessages.init);
      _G.msg.post("board:/board#script",Messages.start_level,_hx_o({__fields__={difficulty=true},difficulty=1}));
      _G.msg.post(sender,defold.GoMessages.enable);
      _self.state = "GAME_RUNNING";
    elseif (message_id) == Messages.start_game then 
      _G.msg.post("#background",defold.GoMessages.disable);
      _G.msg.post("#boardproxy",defold.CollectionproxyMessages.load);
      _G.msg.post("#menu",defold.GoMessages.disable);
    elseif (message_id) == Messages.to_main_menu then 
      if (_self.state ~= "MAIN_MENU") then 
        _G.msg.post("#boardproxy",defold.CollectionproxyMessages.unload);
      end;
      _G.msg.post("main:/main#menu",defold.GoMessages.enable);
      _G.msg.post("#background",defold.GoMessages.enable);
      _self.state = "MAIN_MENU"; end;
  end
)
Main.__super__ = defold.support.Script
setmetatable(Main.prototype,{__index=defold.support.Script.prototype})

Math.new = {}
Math.isNaN = function(f) 
  do return f ~= f end;
end

Messages.new = {}

String.new = {}
String.__index = function(s,k) 
  if (k == "length") then 
    do return _G.string.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        do return String.__oldindex[k] end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.fromCharCode = function(code) 
  do return _G.string.char(code) end;
end
String.prototype = _hx_a(
  'toString', function(self) 
    do return self end
  end
)

Std.new = {}
Std.string = function(s) 
  do return lua.Boot.__string_rec(s) end;
end
Std.int = function(x) 
  do return _hx_bit_clamp(x) end;
end
Std.random = function(x) 
  if (x <= 0) then 
    do return 0 end;
  else
    do return _G.math.floor(_G.math.random() * x) end;
  end;
end

defold.CollectionproxyMessages.new = {}

defold.GoMessages.new = {}

defold.GoProperties.new = {}

defold.GuiMessages.new = {}

defold.SpriteMessages.new = {}

defold.support.GuiScript.new = function() 
  local self = _hx_new(defold.support.GuiScript.prototype)
  defold.support.GuiScript.super(self)
  return self
end
defold.support.GuiScript.super = function(self) 
end
defold.support.GuiScript.prototype = _hx_a(
  'init', function(self,_self) 
  end,
  'final', function(self,_self) 
  end,
  'update', function(self,_self,dt) 
  end,
  'on_message', function(self,_self,message_id,message,sender) 
  end,
  'on_input', function(self,_self,action_id,action) 
    do return false end
  end,
  'on_reload', function(self,_self) 
  end
)

defold.types._Message.Message_Impl_.new = {}
defold.types._Message.Message_Impl_._new = function(s) 
  do return _G.hash(s) end;
end

defold.types._Property.Property_Impl_.new = {}
defold.types._Property.Property_Impl_._new = function(name) 
  do return _G.hash(name) end;
end

defold.types._Property.Vector3Property_Impl_.new = {}
defold.types._Property.Vector3Property_Impl_._new = function(name) 
  do return _G.hash(name) end;
end
defold.types._Property.Vector3Property_Impl_.get_x = function(this1) 
  do return _G.hash(Std.string(this1) .. ".x") end;
end
defold.types._Property.Vector3Property_Impl_.get_y = function(this1) 
  do return _G.hash(Std.string(this1) .. ".y") end;
end
defold.types._Property.Vector3Property_Impl_.get_z = function(this1) 
  do return _G.hash(Std.string(this1) .. ".z") end;
end

defold.types._Property.Vector4Property_Impl_.new = {}
defold.types._Property.Vector4Property_Impl_._new = function(name) 
  do return _G.hash(name) end;
end
defold.types._Property.Vector4Property_Impl_.get_x = function(this1) 
  do return _G.hash(Std.string(this1) .. ".x") end;
end
defold.types._Property.Vector4Property_Impl_.get_y = function(this1) 
  do return _G.hash(Std.string(this1) .. ".y") end;
end
defold.types._Property.Vector4Property_Impl_.get_z = function(this1) 
  do return _G.hash(Std.string(this1) .. ".z") end;
end
defold.types._Property.Vector4Property_Impl_.get_w = function(this1) 
  do return _G.hash(Std.string(this1) .. ".w") end;
end

defold.types._Property.QuaternionProperty_Impl_.new = {}
defold.types._Property.QuaternionProperty_Impl_._new = function(name) 
  do return _G.hash(name) end;
end
defold.types._Property.QuaternionProperty_Impl_.get_x = function(this1) 
  do return _G.hash(Std.string(this1) .. ".x") end;
end
defold.types._Property.QuaternionProperty_Impl_.get_y = function(this1) 
  do return _G.hash(Std.string(this1) .. ".y") end;
end
defold.types._Property.QuaternionProperty_Impl_.get_z = function(this1) 
  do return _G.hash(Std.string(this1) .. ".z") end;
end
defold.types._Property.QuaternionProperty_Impl_.get_w = function(this1) 
  do return _G.hash(Std.string(this1) .. ".w") end;
end

gui.Board.new = function() 
  local self = _hx_new(gui.Board.prototype)
  gui.Board.super(self)
  return self
end
gui.Board.super = function(self) 
  defold.support.GuiScript.super(self);
end
_hx_exports["gui"]["Board"] = gui.Board
gui.Board.prototype = _hx_a(
  'init', function(self,_) 
    _G.msg.post("#",Messages.show);
    _G.msg.post("/restart#gui",Messages.hide);
    _G.msg.post("/level_complete#gui",Messages.hide);
  end,
  'on_message', function(self,_,message_id,message,_1) 
    if (message_id) == Messages.hide then 
      _G.msg.post("#",defold.GoMessages.disable);
    elseif (message_id) == Messages.set_drop_counter then 
      _G.gui.set_text(_G.gui.get_node("drop_counter"),message.drops .. " x");
    elseif (message_id) == Messages.show then 
      _G.msg.post("#",defold.GoMessages.enable); end;
  end,
  'on_input', function(self,_,action_id,action) 
    if ((action_id == _G.hash("touch")) and action.pressed) then 
      local restart = _G.gui.get_node("restart");
      local drop = _G.gui.get_node("drop");
      if (_G.gui.pick_node(restart,action.x,action.y)) then 
        _G.msg.post("/restart#gui",Messages.show);
        _G.msg.post("#",Messages.hide);
      else
        if (_G.gui.pick_node(drop,action.x,action.y)) then 
          _G.msg.post("/board#script",Messages.drop);
        end;
      end;
    end;
    do return false end
  end
)
gui.Board.__super__ = defold.support.GuiScript
setmetatable(gui.Board.prototype,{__index=defold.support.GuiScript.prototype})

gui.LevelComplete.new = function() 
  local self = _hx_new(gui.LevelComplete.prototype)
  gui.LevelComplete.super(self)
  return self
end
gui.LevelComplete.super = function(self) 
  defold.support.GuiScript.super(self);
end
_hx_exports["gui"]["LevelComplete"] = gui.LevelComplete
gui.LevelComplete.prototype = _hx_a(
  'init', function(self,_) 
    _G.msg.post("#",Messages.hide);
  end,
  'on_message', function(self,_,message_id,_1,_2) 
    if (message_id) == Messages.hide then 
      _G.msg.post("#",defold.GoMessages.disable);
      _G.msg.post(".",defold.GoMessages.release_input_focus);
    elseif (message_id) == Messages.show then 
      _G.msg.post("#",defold.GoMessages.enable);
      _G.msg.post(".",defold.GoMessages.acquire_input_focus); end;
  end,
  'on_input', function(self,_,action_id,action) 
    if ((action_id == _G.hash("touch")) and action.pressed) then 
      if (_G.gui.pick_node(_G.gui.get_node("continue"),action.x,action.y)) then 
        _G.msg.post("board#script",Messages.next_level);
        _G.msg.post("#",Messages.hide);
      end;
    end;
    do return true end
  end
)
gui.LevelComplete.__super__ = defold.support.GuiScript
setmetatable(gui.LevelComplete.prototype,{__index=defold.support.GuiScript.prototype})

gui.MainMenu.new = function() 
  local self = _hx_new(gui.MainMenu.prototype)
  gui.MainMenu.super(self)
  return self
end
gui.MainMenu.super = function(self) 
  defold.support.GuiScript.super(self);
end
_hx_exports["gui"]["MainMenu"] = gui.MainMenu
gui.MainMenu.prototype = _hx_a(
  'init', function(self,_) 
    _G.msg.post(".",defold.GoMessages.acquire_input_focus);
    local bs = _hx_tab_array({[0]="brick1", "brick2", "brick3", "brick4", "brick5", "brick6" }, 6);
    local _g = 0;
    while (_g < bs.length) do 
      local b = bs[_g];
      _g = _g + 1;
      local n = _G.gui.get_node(b);
      local rt = (_G.math.random() * 3) + 1;
      local a = _G.math.random(-45,45);
      _G.gui.set_color(n,_G.vmath.vector4(1,1,1,0));
      _G.gui.animate(n,"position.y",-100 - _G.math.random(0,50),_G.gui.EASING_INSINE,1 + rt,0,nil,_G.gui.PLAYBACK_LOOP_FORWARD);
      _G.gui.animate(n,"color.w",1,_G.gui.EASING_INSINE,1 + rt,0,nil,_G.gui.PLAYBACK_LOOP_FORWARD);
      _G.gui.animate(n,"rotation.z",a,_G.gui.EASING_INSINE,1 + rt,0,nil,_G.gui.PLAYBACK_LOOP_FORWARD);
      end;
    _G.gui.animate(_G.gui.get_node("start"),"color.x",1,_G.gui.EASING_INOUTSINE,1,0,nil,_G.gui.PLAYBACK_LOOP_PINGPONG);
  end,
  'on_input', function(self,_,action_id,action) 
    if ((action_id == _G.hash("touch")) and action.pressed) then 
      if (_G.gui.pick_node(_G.gui.get_node("start"),action.x,action.y)) then 
        _G.msg.post("/main#script",Messages.start_game);
      end;
    end;
    do return false end
  end
)
gui.MainMenu.__super__ = defold.support.GuiScript
setmetatable(gui.MainMenu.prototype,{__index=defold.support.GuiScript.prototype})

gui.NoDropRoom.new = function() 
  local self = _hx_new(gui.NoDropRoom.prototype)
  gui.NoDropRoom.super(self)
  return self
end
gui.NoDropRoom.super = function(self) 
  defold.support.GuiScript.super(self);
end
_hx_exports["gui"]["NoDropRoom"] = gui.NoDropRoom
gui.NoDropRoom.prototype = _hx_a(
  'init', function(self,_self) 
    _G.msg.post("#",Messages.hide);
    _self.t = 0;
  end,
  'update', function(self,_self,dt) 
    if (_self.t < 0) then 
      _G.msg.post("#",Messages.hide);
    else
      _self.t = _self.t - dt;
    end;
  end,
  'on_message', function(self,_self,message_id,message,_) 
    if (message_id) == Messages.hide then 
      _G.msg.post("#",defold.GoMessages.disable);
    elseif (message_id) == Messages.show then 
      _self.t = 1;
      _G.msg.post("#",defold.GoMessages.enable); end;
  end
)
gui.NoDropRoom.__super__ = defold.support.GuiScript
setmetatable(gui.NoDropRoom.prototype,{__index=defold.support.GuiScript.prototype})

gui.PresentLevel.new = function() 
  local self = _hx_new(gui.PresentLevel.prototype)
  gui.PresentLevel.super(self)
  return self
end
gui.PresentLevel.super = function(self) 
  defold.support.GuiScript.super(self);
end
_hx_exports["gui"]["PresentLevel"] = gui.PresentLevel
gui.PresentLevel.prototype = _hx_a(
  'init', function(self,_) 
    _G.msg.post("#",Messages.hide);
  end,
  'on_message', function(self,_,message_id,message,_1) 
    if (message_id) == gui.PresentLevel.ShowMessage then 
      _G.gui.set_text(_G.gui.get_node("message"),"Level " .. message.level);
      _G.msg.post("#",defold.GoMessages.enable);
    elseif (message_id) == Messages.hide then 
      _G.msg.post("#",defold.GoMessages.disable); end;
  end
)
gui.PresentLevel.__super__ = defold.support.GuiScript
setmetatable(gui.PresentLevel.prototype,{__index=defold.support.GuiScript.prototype})

gui.Restart.new = function() 
  local self = _hx_new(gui.Restart.prototype)
  gui.Restart.super(self)
  return self
end
gui.Restart.super = function(self) 
  defold.support.GuiScript.super(self);
end
_hx_exports["gui"]["Restart"] = gui.Restart
gui.Restart.prototype = _hx_a(
  'on_message', function(self,_,message_id,message,_1) 
    if (message_id) == Messages.hide then 
      _G.msg.post("#",defold.GoMessages.disable);
      _G.msg.post(".",defold.GoMessages.release_input_focus);
    elseif (message_id) == Messages.show then 
      _G.msg.post("#",defold.GoMessages.enable);
      _G.msg.post(".",defold.GoMessages.acquire_input_focus); end;
  end,
  'on_input', function(self,_,action_id,action) 
    if ((action_id == _G.hash("touch")) and action.pressed) then 
      local yes = _G.gui.get_node("yes");
      local no = _G.gui.get_node("no");
      local quit = _G.gui.get_node("quit");
      if (_G.gui.pick_node(no,action.x,action.y)) then 
        _G.msg.post("#",Messages.hide);
        _G.msg.post("/board#gui",Messages.show);
      else
        if (_G.gui.pick_node(yes,action.x,action.y)) then 
          _G.msg.post("board:/board#script",Messages.restart_level);
          _G.msg.post("/board#gui",Messages.show);
          _G.msg.post("#",Messages.hide);
        else
          if (_G.gui.pick_node(quit,action.x,action.y)) then 
            _G.msg.post("main:/main#script",Messages.to_main_menu);
            _G.msg.post("#",Messages.hide);
          end;
        end;
      end;
    end;
    do return true end
  end
)
gui.Restart.__super__ = defold.support.GuiScript
setmetatable(gui.Restart.prototype,{__index=defold.support.GuiScript.prototype})

haxe.Log.new = {}
haxe.Log.trace = function(v,infos) 
  local str = nil;
  if (infos ~= nil) then 
    str = infos.fileName .. ":" .. infos.lineNumber .. ": " .. Std.string(v);
    if (infos.customParams ~= nil) then 
      str = str .. ("," .. infos.customParams:join(","));
    end;
  else
    str = v;
  end;
  if (str == nil) then 
    str = "null";
  end;
  _hx_print(str);
end

haxe.io.Eof.new = {}
haxe.io.Eof.prototype = _hx_a(
  'toString', function(self) 
    do return "Eof" end
  end
)

lua.Boot.new = {}
lua.Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
lua.Boot.printEnum = function(o,s) 
  if (o.length == 2) then 
    do return o[0] end;
  else
    local str = Std.string(o[0]) .. "(";
    s = s .. "\t";
    local _g1 = 2;
    local _g = o.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (i ~= 2) then 
        str = str .. ("," .. lua.Boot.__string_rec(o[i],s));
      else
        str = str .. lua.Boot.__string_rec(o[i],s);
      end;
      end;
    do return str .. ")" end;
  end;
end
lua.Boot.printClassRec = function(c,result,s) 
  if (result == nil) then 
    result = "";
  end;
  local f = lua.Boot.__string_rec;
  for k,v in pairs(c) do if result ~= '' then result = result .. ', ' end result = result .. k .. ':' .. f(v, s.. '	') end;
  do return result end;
end
lua.Boot.__string_rec = function(o,s) 
  if (s == nil) then 
    s = "";
  end;
  local _g = type(o);
  local _g1 = _g;
  if (_g1) == "boolean" then 
    do return tostring(o) end;
  elseif (_g1) == "function" then 
    do return "<function>" end;
  elseif (_g1) == "nil" then 
    do return "null" end;
  elseif (_g1) == "number" then 
    if (o == _G.math.huge) then 
      do return "Infinity" end;
    else
      if (o == -_G.math.huge) then 
        do return "-Infinity" end;
      else
        if (o ~= o) then 
          do return "NaN" end;
        else
          do return tostring(o) end;
        end;
      end;
    end;
  elseif (_g1) == "string" then 
    do return o end;
  elseif (_g1) == "table" then 
    if (o.__enum__ ~= nil) then 
      do return lua.Boot.printEnum(o,s) end;
    else
      if ((o.toString ~= nil) and not lua.Boot.isArray(o)) then 
        do return o:toString() end;
      else
        if (lua.Boot.isArray(o)) then 
          local o2 = o;
          if (s.length > 5) then 
            do return "[...]" end;
          else
            local _g2 = _hx_tab_array({ }, 0);
            local _g11 = 0;
            while (_g11 < o2.length) do 
              local i = o2[_g11];
              _g11 = _g11 + 1;
              _g2:push(lua.Boot.__string_rec(i,s .. 1));
              end;
            do return "[" .. _g2:join(",") .. "]" end;
          end;
        else
          if (o.__class__ ~= nil) then 
            do return "{" .. lua.Boot.printClassRec(o,"",s .. "\t") .. "}" end;
          else
            local fields = lua.Boot.fieldIterator(o);
            local buffer = ({});
            local first = true;
            _G.table.insert(buffer,"{ ");
            local f = fields;
            while (f:hasNext()) do 
              local f1 = f:next();
              if (first) then 
                first = false;
              else
                _G.table.insert(buffer,", ");
              end;
              _G.table.insert(buffer,"" .. Std.string(f1) .. " : " .. Std.string(o[f1]));
              end;
            _G.table.insert(buffer," }");
            do return _G.table.concat(buffer,"") end;
          end;
        end;
      end;
    end;
  elseif (_g1) == "thread" then 
    do return "<thread>" end;
  elseif (_g1) == "userdata" then 
    do return "<userdata>" end;else
  _G.error("Unknown Lua type",0); end;
end
lua.Boot.fieldIterator = function(o) 
  local tbl = (function() 
    local _hx_1
    if (o.__fields__ ~= nil) then 
    _hx_1 = o.__fields__; else 
    _hx_1 = o; end
    return _hx_1
  end )();
  local cur = _G.pairs(tbl);
  local next_valid = function(tbl1,val) 
    while (lua.Boot.hiddenFields[val] ~= nil) do 
      val = cur(tbl1,val);
      end;
    do return val end;
  end;
  local cur_val = next_valid(tbl,cur(tbl,nil));
  do return _hx_o({__fields__={next=true,hasNext=true},next=function() 
    local ret = cur_val;
    cur_val = next_valid(tbl,cur(tbl,cur_val));
    do return ret end;
  end,hasNext=function() 
    do return cur_val ~= nil end;
  end}) end;
end
_hx_bit_clamp = function(v) 
  if v <= 2147483647 and v >= -2147483648 then
    if v > 0 then return _G.math.floor(v)
    else return _G.math.ceil(v)
    end
  end
  if v > 2251798999999999 then v = v*2 end;
  if (v ~= v or math.abs(v) == _G.math.huge) then return nil end
  return _hx_bit.band(v, 2147483647 ) - math.abs(_hx_bit.band(v, 2147483648))
end
pcall(require, 'bit')
if bit then
  _hx_bit = bit
elseif bit32 then
  local _hx_bit_raw = bit32
  _hx_bit = setmetatable({}, { __index = _hx_bit_raw });
  _hx_bit.bnot = function(...) return _hx_bit_clamp(_hx_bit_raw.bnot(...)) end;
  _hx_bit.bxor = function(...) return _hx_bit_clamp(_hx_bit_raw.bxor(...)) end;
end
local _hx_string_mt = _G.getmetatable('');
String.__oldindex = _hx_string_mt.__index;
_hx_string_mt.__index = String.__index;
_hx_string_mt.__add = function(a,b) return Std.string(a)..Std.string(b) end;
_hx_string_mt.__concat = _hx_string_mt.__add
_hx_array_mt.__index = Array.prototype

Board.REMOVING_BLOCK = _hx_o({__fields__={id=true,color=true,x=true,y=true},id=nil,color=nil,x=-1,y=-1})
Board.blocksize = 80
Board.edge = 40
Board.bottom_edge = 50
Board.boardwidth = 7
Board.boardheight = 9
Board.centeroff = _G.vmath.vector3(8,-8,0)
Board.dropamount = 3
Board.colors = _hx_tab_array({[0]=_G.hash("orange"), _G.hash("pink"), _G.hash("blue"), _G.hash("yellow"), _G.hash("green") }, 5)
Messages.start_game = _G.hash("start_game")
Messages.start_level = _G.hash("start_level")
Messages.next_level = _G.hash("next_level")
Messages.restart_level = _G.hash("restart_level")
Messages.level_completed = _G.hash("level_completed")
Messages.to_main_menu = _G.hash("to_main_menu")
Messages.hide = _G.hash("hide")
Messages.show = _G.hash("show")
Messages.drop = _G.hash("drop")
Messages.set_drop_counter = _G.hash("set_drop_counter")
Messages.make_magic = _G.hash("make_magic")
Messages.lights_on = _G.hash("lights_on")
Messages.lights_off = _G.hash("lights_off")
defold.CollectionproxyMessages.async_load = _G.hash("async_load")
defold.CollectionproxyMessages.disable = _G.hash("disable")
defold.CollectionproxyMessages.enable = _G.hash("enable")
defold.CollectionproxyMessages.final = _G.hash("final")
defold.CollectionproxyMessages.init = _G.hash("init")
defold.CollectionproxyMessages.load = _G.hash("load")
defold.CollectionproxyMessages.proxy_loaded = _G.hash("proxy_loaded")
defold.CollectionproxyMessages.proxy_unloaded = _G.hash("proxy_unloaded")
defold.CollectionproxyMessages.set_time_step = _G.hash("set_time_step")
defold.CollectionproxyMessages.unload = _G.hash("unload")
defold.GoMessages.acquire_input_focus = _G.hash("acquire_input_focus")
defold.GoMessages.disable = _G.hash("disable")
defold.GoMessages.enable = _G.hash("enable")
defold.GoMessages.release_input_focus = _G.hash("release_input_focus")
defold.GoMessages.request_transform = _G.hash("request_transform")
defold.GoMessages.set_parent = _G.hash("set_parent")
defold.GoMessages.transform_response = _G.hash("transform_response")
defold.GoProperties.euler = _G.hash("euler")
defold.GoProperties.position = _G.hash("position")
defold.GoProperties.rotation = _G.hash("rotation")
defold.GoProperties.scale = _G.hash("scale")
defold.GoProperties.scale_uniform = _G.hash("scale")
defold.GuiMessages.layout_changed = _G.hash("layout_changed")
defold.SpriteMessages.animation_done = _G.hash("animation_done")
defold.SpriteMessages.play_animation = _G.hash("play_animation")
gui.PresentLevel.ShowMessage = _G.hash("show")
lua.Boot.hiddenFields = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}
do

end
_G.math.randomseed(_G.os.time());
_hx_print = print or (function() end)
return _hx_exports
